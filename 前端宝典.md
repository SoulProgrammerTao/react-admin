# Axios封装
```
import axios from 'axios'
import { Message } from 'antd'

// 创建一个axios对象
const service = axios.create({
  baseURL: '', // 配置基础路径
  headers: {
    'Content-Type': 'application/json'
  },
  timeout: 20000 // 请求超时设置
})

// 添加请求拦截器
service.interceptors.request.use(function (config) {
    // 在发送请求之前做些什么
    return config;
  }, function (error) {
    // 对请求错误做些什么
    return Promise.reject(error);
  });

export default function Request (url, data={}, type='GET') {
  const config = type === 'GET' ? {url, params: data} : { url, data, method: 'POST' }
  return new Promise((resolve, reject) => {
    service(config).then(res => {
      resolve(res.data)
    }).catch(err => {
      Message.error('请求出错了: ' + err.message)
    })
  })
}
```

# Vue
## vue-cli
  + `npm install -g @vue/cli `
  + `vue create project`

# React

## react-cli

  + `npm i npx -g`
  
  + `npx create-react-app project`
  
  + `npm run eject`
  
  + 热更新`react-hot-loader`

## 按需加载antD组件

+ ```yarn add antd```

+ ```$ yarn add react-app-rewired customize-cra```

  ```
  /* package.json */
  "scripts": {
  -   "start": "react-scripts start",
  +   "start": "react-app-rewired start",
  -   "build": "react-scripts build",
  +   "build": "react-app-rewired build",
  -   "test": "react-scripts test",
  +   "test": "react-app-rewired test",
  }
  ```

  + 然后在项目根目录创建一个 `config-overrides.js` 用于修改默认配置。

    ```
    module.exports = function override(config, env) {
      // do stuff with the webpack config...
      return config;
    };
    ```

+ ```yarn add babel-plugin-import```

  ```
  /* config-overrides.js */
  + const { override, fixBabelImports } = require('customize-cra');
  
  - module.exports = function override(config, env) {
  -   // do stuff with the webpack config...
  -   return config;
  - };
  + module.exports = override(
  +   fixBabelImports('import', {
  +     libraryName: 'antd',
  +     libraryDirectory: 'es',
  +     style: 'css',
  +   }),
  + );
  ```

+ ```yarn start```重启

  

## 路由

  + ```yarn add react-router-dom ```

  + 引入```import { BrowserRouter, Route, Switch } from "react-router-dom"```

  + 定义路由数组

    ```
    const routes = [
      {path: "/", component: Home},
      {path: "/register", component: Register},
      {path: "/part1", component: Part1}
    ]
    ```
    
   + 渲染路由组件

     ```
     class App extends Component {
       render() {
         return (
           <div>
             <BrowserRouter>
             {
               routes.map((page, index) => page.component ? <Route key={index} exact path={page.path} component={page.component}/> : "")
             }
             </BrowserRouter>
           </div>
         );
       }
     }
     ```

## 配置 Sass / Less

+ Sass 

  + create-react-app 脚手架中已经添加了sass-loader的支持，只需安装node-sass插件即可

  + 安装插件 ``` $ yarn add node-sass```

+ Less

  + 由于 create-react-app 脚手架中并没有配置关于 less 文件的解析，所以我们需要自己进行配置。需要安装的插件 `less`， `less-loader`

  + 添加less相关配置

    + 在命令行运行 `npm run eject` 命令。 发射配置文件，此过程不可逆

    + 运行完成之后，打开 config 目录下的 webpack.config.js 文件，找到 `// style files regexes` 注释位置，仿照其解析 sass 的规则，在下面添加两行代码

      ```
      // 添加 less 解析规则
      const lessRegex = /\.less$/;
      const lessModuleRegex = /\.module\.less$/;
      ```
      
    + 找到 rules 属性配置，在其中添加 less 解析配置
    
      ```
      !!!注意： 这里有一个需要注意的地方，下面的这些 less 配置规则放在 sass 的解析规则下面即可，如果放在了 file-loader 的解析规则下面，less 文件解析不会生效。
      ```
    
      ```
      // Less 解析配置
      {
          test: lessRegex,
          exclude: lessModuleRegex,
          use: getStyleLoaders(
              {
                  importLoaders: 2,
                  sourceMap: isEnvProduction && shouldUseSourceMap,
              },
              'less-loader'
          ),
          sideEffects: true,
      },
      {
          test: lessModuleRegex,
          use: getStyleLoaders(
              {
                  importLoaders: 2,
                  sourceMap: isEnvProduction && shouldUseSourceMap,
                  modules: true,
                  getLocalIdent: getCSSModuleLocalIdent,
              },
              'less-loader'
          )
      }
      ```
    
    + 此时配置完成，安装 less 和 less-loader 插件即可
    
      ```
      $ npm install less less-loader --save
      ```
    
      


## 事件绑定

  + 不需要绑定this

  ```javascript
  class LoggingButton extends React.Component {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    // 注意: 这是 *实验性* 语法。
    handleClick = () => { // ES6箭头函数
      console.log('this is:', this);
    }
  
    render() {
      return (
        <button onClick={this.handleClick}>
          Click me
        </button>
      );
    }
  }
  ```
  + 绑定this
  
    + 箭头函数绑定this
    
      ```javascript
      class LoggingButton extends React.Component {
        handleClick() {
          console.log('this is:', this);
        }
      
        render() {
          // 此语法确保 `handleClick` 内的 `this` 已被绑定。
          return (
            <button onClick={(e) => this.handleClick(e)}>
              Click me
            </button>
          );
        }
      }
      ```
    
    + bind绑定this
    
      ```javascript
      class LoggingButton extends React.Component {
        handleClick() {
          console.log('this is:', this);
        }
      
        render() {
          // 此语法确保 `handleClick` 内的 `this` 已被绑定。
          return (
            <button onClick={this.handleClick.bind(this)}>
              Click me
            </button>
          );
        }
      }
      ```

## 组件

## 生命周期函数

+ **第一阶段 ---初始化** 

  ```javascript
  constructor // 初始化状态
  componentWillMount // 组件即将渲染
  reder // 渲染组件
  componentDidMout // 组件已渲染完成
  ```
  
+ **第二阶段 -- 运行中** 

  ```
  1.如果属性（props)改变
      componentWillReceiveProps // 组件获取更新后的props
      shouldComponentUpdate // 组件是否更新 ---若为false，继续运行不往下执行生命周期函数，若为true继续执行
      componentWillUpdate // 组件即将更新
      render // 渲染组件
      componentDidUpdate // 组件更新完成
  2.如果状态（state)改变
      shouldComponentUpdate // 组件是否更新 ---若为false，继续运行不往下执行生命周期函数，若为true继续执行
      componentWillUpdate // 组件即将更新
      render // 渲染组件
      componentDidUpdate // 组件更新完成
  ```

+ **第三阶段 --销毁**

  ```javascript
  componentWillUnmount // 组件销毁前执行
  ```

## 事件处理

## Redux

# Express

# NodeJS

# sessionStorage共享

+ **同域名下，多个tab标签页sessionStorage数据共享**

```javascript
/* 註：此範例為複製全部sessionStorage內資料 */
(() => {
  // 判斷當前頁面是否存在sessionStorage
  if (!window.sessionStorage.length) {
    // 若不存在則加上一個localStorage Item, Key = getSessionStorageData
    window.localStorage.setItem('getSessionStorageData', Date.now())
  }
  // 增加window監聽事件'storage'
  window.addEventListener('storage', (event) => {
    // 如果偵聽到的事件是key是getSessionStorageData
    if (event.key === 'getSessionStorageData') {
      // 再新增一個localstorage Item, key = sessionStorageData，value就是當前的sessionStorage
      window.localStorage.setItem('sessionStorageData', JSON.stringify(window.sessionStorage))
      // 刪除localstorage中key = sessionStorageData的item
      window.localStorage.removeItem('sessionStorageData')
    }
    // 如果偵聽到的事件是key是sessionStorageData, 且當前的sessionStorage是空的
    if (event.key === 'sessionStorageData' && !window.sessionStorage.length) {
      // 把sessionStorageData的資料parse出來
      const data = JSON.parse(event.newValue)
      // 賦值到當前頁面的sessionStorage中
      for (const key in data) {
        window.sessionStorage.setItem(key, data[key])
      }
    }
  })
})()
```


